#include "HestonModel.h" // Use the paths generated by HestonModel
#include <vector>  // Use create vectors of paths and back function
#include <cmath>  // Use for max function 
#include <numeric> // Use for accumulate function
#include <omp.h> // Use for parallel for loop
using namespace std; // Use standard namespace

// In this cpp file, we define a class LMM_DD that
// use the paths generated by HestonModel to calculate
// the forward rates, caplet price and swap option price
// using the Libor Market Model with Displacement Diffusion
// For theoretical background, refer to the following book:
// Lech A. Grzelak, Cornelis W. Oosterlee, 
//"Mathematical Modeling and Computation in Finance: With Exercises and Python and MATLAB Computer Codes"

class LMM_DD{ // Define a class for Libor Market Model with Displacement Diffusion
    public:
    vector<vector<double> > Forward_rates(int NoOfPaths, int NoOfSteps, double T,
    double r, double S_0, double kappa,
    double gamma, double rho, double vbar, double v0, double beta, double sigma);
    double Caplet_price(const vector<vector<double> >& paths, double K);
    double Floorlet_price(const vector<vector<double> >& forwardRates, double K);
};


vector<vector<double> > LMM_DD :: Forward_rates(int NoOfPaths, int NoOfSteps, double T,
     double r, double S_0, double kappa,
    double gamma, double rho, double vbar, double v0, double beta, double sigma) {
    // I use const for paths that are not modified
    // I use & for paths that are passed by reference, reducing the overhead of copying
    Heston Heston;  // Create an paths using HestonModel
    double gamma_hat = beta * gamma * sigma; // Define parameters for model
    double v_bar_hat = pow(beta, 2) * vbar * pow(sigma, 2);
    double v0_hat = pow(beta, 2) * v0 * pow(sigma, 2); 
    vector<vector<double> > forwardRates = Heston.GeneratePathsHestonAES(NoOfPaths, NoOfSteps, T, r, S_0, kappa, gamma_hat, rho, v_bar_hat, v0_hat);

    return forwardRates;
};




double LMM_DD ::Caplet_price(const vector<vector<double> >& forwardRates, double K) {
    int NoOfPaths = forwardRates.size(); // Number of paths
    vector<double> payoffs(NoOfPaths); // Payoffs function
    const double dt = 1.0 / forwardRates.size(); // Define tenor

    // Calculate payoff for each path
    #pragma omp parallel for
    for (int i = 0; i < NoOfPaths; ++i) {
        double discountFactor = 1.0 / (1.0 + forwardRates[i].back() * dt);
        // For discount factor, I use HJM framework for discount factor
        // and HJM framwork claim that discount factor equal the instantaneous forward rate
        // I use forward rate *  dt, due to the fact that the forward rate determine the T_k
        // and payoff T_k+1
        double S_T = forwardRates[i].back(); // Final price at maturity
        payoffs[i] = max(S_T - K, 0.0) * discountFactor;
    }
    return accumulate(payoffs.begin(), payoffs.end(), 0.0) / NoOfPaths;

};


double LMM_DD::Floorlet_price(const vector<vector<double> >& forwardRates, double K) {
        int NoOfPaths = forwardRates.size(); // Number of paths
    vector<double> payoffs(NoOfPaths); // Payoffs function
    const double dt = 1.0 / forwardRates.size(); // Define tenor

    // Calculate payoff for each path
    #pragma omp parallel for
    for (int i = 0; i < NoOfPaths; ++i) {
        double discountFactor = 1.0 / (1.0 + forwardRates[i].back() * dt);
        // For discount factor, I use HJM framework for discount factor
        // and HJM framwork claim that discount factor equal the instantaneous forward rate
        // I use forward rate *  dt, due to the fact that the forward rate determine the T_k
        // and payoff T_k+1
        double S_T = forwardRates[i].back(); // Final price at maturity
        payoffs[i] = max(K - S_T, 0.0) * discountFactor;
    }
    return accumulate(payoffs.begin(), payoffs.end(), 0.0) / NoOfPaths;
    }


