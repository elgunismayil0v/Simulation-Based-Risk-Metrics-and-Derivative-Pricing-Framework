#include "HestonModel.h" // Use the paths generated by HestonModel
#include <vector>  // Use create vectors of paths and back function
#include <cmath>  // Use for max function 
#include <numeric> // Use for accumulate function
#include <omp.h> // Use for parallel for loop
using namespace std; // Use standard namespace

// In this cpp file, we define a class LMM_DD that
// use the paths generated by HestonModel to calculate
// the forward rates, caplet price and swap option price
// using the Libor Market Model with Displacement Diffusion
// For theoretical background, refer to the following book:
// Lech A. Grzelak, Cornelis W. Oosterlee, 
//"Mathematical Modeling and Computation in Finance: With Exercises and Python and MATLAB Computer Codes"
// 12 and 14 chapter

class LMM_DD{ // Define a class for Libor Market Model with Displacement Diffusion
    public:
    vector<vector<double> > Forward_rates(vector<vector<double>>variance_paths, int NoOfPaths, int NoOfSteps, double T,
    double r, double S_0, double kappa,
    double gamma, double rho, double vbar, double v0, double beta, double sigma);
    double Caplet_price(const vector<vector<double> >& paths, double K);
    double Swap_option_price(const vector<vector<double> >& Forward_rates, double K);
};


vector<vector<double> > LMM_DD :: Forward_rates(vector<vector<double>>variance_paths,int NoOfPaths, int NoOfSteps, double T,
     double r, double S_0, double kappa,
    double gamma, double rho, double vbar, double v0, double beta, double sigma) {
    // I use const for paths that are not modified
    // I use & for paths that are passed by reference, reducing the overhead of copying
    Heston Heston;  // Create an paths using HestonModel
    double gamma_hat = beta * gamma * sigma; // Define parameters for model
    double v_bar_hat = pow(beta, 2) * vbar * pow(sigma, 2);
    double v0_hat = pow(beta, 2) * v0 * pow(sigma, 2); 
    vector<vector<double> > forwardRates = Heston.GeneratePathsHestonAES(variance_paths,NoOfPaths, NoOfSteps, T, r, S_0, kappa, gamma_hat, rho, v_bar_hat);

    return forwardRates;
};




double LMM_DD ::Caplet_price(const vector<vector<double> >& forwardRates, double K) {
    int NoOfPaths = forwardRates.size(); // Number of paths
    vector<double> payoffs(NoOfPaths); // Payoffs function
    const double dt = 1.0 / forwardRates.size(); // Define tenor

    // Calculate payoff for each path
    #pragma omp parallel for
    for (int i = 0; i < NoOfPaths; ++i) {
        double discountFactor = 1.0 / (1.0 + forwardRates[i].back() * dt);
        // For discount factor, I use HJM framework for discount factor
        // and HJM framwork claim that discount factor equal the instantaneous forward rate
        // I use forward rate *  dt, due to the fact that the forward rate determine the T_k
        // and payoff T_k+1
        double S_T = forwardRates[i].back(); // Final price at maturity
        payoffs[i] = max(S_T - K, 0.0) * discountFactor;
    }
    return accumulate(payoffs.begin(), payoffs.end(), 0.0) / NoOfPaths;

}




double LMM_DD::Swap_option_price(const vector<vector<double>>& Forward_rates, double K) {
    int NoofPaths = Forward_rates.size(); // Number of rows
    int n = Forward_rates[0].size();     // Number of columns (time steps)
    double t_k = 1.0 / n;                // Tenor
    
    // Initialize vectors
    vector<vector<double>> P_0(NoofPaths, vector<double>(n, 0.0)); // Zero coupon bond matrix
    vector<double> annuity_factor(NoofPaths, 0.0);                 // Annuity factor
    vector<double> Value_of_payer_swap(NoofPaths, 0.0);            // Payoff function

    // Set initial bond price
    #pragma omp parallel for
    for (int i = 0; i < NoofPaths; i++) {
        P_0[i][0] = 1.0; // Initial value for all paths
   

    // Calculate bond prices and annuity factor
        #pragma omp parallel for
        for (int j = 1; j < n; j++) { // Loop over time steps
            P_0[i][j] = P_0[i][j - 1] / (1 + Forward_rates[i][j - 1] * t_k);
        

         // Compute annuity factor
            annuity_factor[i] += P_0[i][j] * t_k;
        }

        // Calculate the value of the payer swap
        Value_of_payer_swap[i] = max(P_0[i][n-1] - P_0[i][n - 2] - K * annuity_factor[i], 0.0);
    }

    // Compute the average payoff across all paths
    return accumulate(Value_of_payer_swap.begin(), Value_of_payer_swap.end(), 0.0) / NoofPaths;
}





